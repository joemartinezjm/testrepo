name: Build and Push Container Images

on:
  push:

env:
  REGISTRY: ghcr.io
  REPO_NAME: ${{ github.repository }}

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.filter.outputs.matrix }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Detect changed folders with Dockerfiles
        id: filter
        run: |
          # Ensure we have a valid commit history (handle new branches & first commits)
          if [ -z "$(git rev-parse --verify ${{ github.event.before }})" ]; then
            echo "Previous commit not found, treating as first commit."
            BASE_REF=$(git rev-list --max-parents=0 HEAD)  # Get first commit
          else
            BASE_REF=${{ github.event.before }}
          fi

          echo "Comparing changes from $BASE_REF to ${{ github.sha }}"

          # Find all directories containing a Dockerfile (ignore .git and hidden folders)
          ALL_FOLDERS=$(find . -mindepth 1 -maxdepth 1 -type d ! -name ".git" ! -name ".*" | sed 's|^\./||' | jq -R -s -c 'split("\n")[:-1]')

          # Detect changed folders (since last commit)
          CHANGED_FOLDERS=$(git diff --name-only $BASE_REF ${{ github.sha }} | awk -F/ '{print $1}' | sort -u | grep -Ev '^(\.git|\.github)$' | jq -R -s -c 'split("\n")[:-1]')

          # Handle newly added folders (that didn't exist in the previous commit)
          NEW_FOLDERS=$(git ls-tree -r --name-only HEAD | awk -F/ '{print $1}' | sort -u | grep -Ev '^(\.git|\.github)$' | jq -R -s -c 'split("\n")[:-1]')

          # Combine changed and new folders
          COMBINED_FOLDERS=$(jq -c -n --argjson a "$CHANGED_FOLDERS" --argjson b "$NEW_FOLDERS" '$a + $b | unique')

          # Use changed folders if detected, otherwise use all folders
          if [[ "$COMBINED_FOLDERS" == "[]" ]]; then
            echo "No specific changes detected, building all images."
            echo "matrix=$ALL_FOLDERS" >> "$GITHUB_OUTPUT"
          else
            echo "Changed or newly added folders detected: $COMBINED_FOLDERS"
            echo "matrix=$COMBINED_FOLDERS" >> "$GITHUB_OUTPUT"
          fi

  build-and-push:
    runs-on: ubuntu-latest
    needs: detect-changes
    if: ${{ needs.detect-changes.outputs.matrix != '[]' }} # Only run if there are changes
    strategy:
      matrix:
        folder: ${{ fromJson(needs.detect-changes.outputs.matrix) }}
    permissions:
      contents: read
      packages: write
      id-token: write
      attestations: write
      
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata (tags, labels) for ${{ matrix.folder }}
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.REPO_NAME }}/${{ matrix.folder }}
          
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3      

      - name: Build and push Docker image for ${{ matrix.folder }}
        id: push
        uses: docker/build-push-action@v6
        with:
          context: ${{ matrix.folder }}
          sbom: true
          push: true
          provenance: mode=max
          platforms: linux/amd64,linux/arm64
          tags: |
            ${{ env.REGISTRY }}/${{ env.REPO_NAME }}/${{ matrix.folder }}:latest
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          load: false

      # - name: Install Cosign
      #   uses: sigstore/cosign-installer@main

      # - name: Sign the container image with Cosign
      #   run: |
      #     cosign sign --yes --key env://COSIGN_PRIVATE_KEY \
      #       ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.push.outputs.digest }}
      #   env:
      #     COSIGN_PRIVATE_KEY: ${{ secrets.COSIGN_PRIVATE_KEY }}

      # - name: Generate Build Provenance Attestation
      #   uses: actions/attest-build-provenance@v1
      #   with:
      #     subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
      #     subject-digest: ${{ steps.push.outputs.digest }}
